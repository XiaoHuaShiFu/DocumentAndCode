# -2、一切都是对象

1. 常量池：存放字符串常量和基本类型常量（public static final）

   常量池：JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。常量池存在于堆中。

   ![](https://images2015.cnblogs.com/blog/1087853/201612/1087853-20161228171311414-415257293.png)

   - final修饰的局部变量是存放在栈中还是在常量池中 ？
     存放在常量池中。
     - 首先final关键字对于变量的存储区域是没有任何影响的。
     - jvm规范中，类的静态变量存储在方法区，实例变量存储在堆区。也就是说static关键字才对变量的存储区域造成影响。final关键字来修饰变量表明了该变量一旦赋值就无法更改。
     - 在Java中你可以这样理解：所有的变量，包括基本类型和引用类型，它们的变量都是存放在栈中，栈中的每个变量都包含类型、名称、值这些内容，只不过基本类型变量的值为一个具体的值，而引用类型的变量的值为对象在堆中的地址。

   - java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。常量池其实也就是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。

2. 基本类型：在栈中直接存储值而非引用。

   - 所有数值类型都有正负号。
   - boolean类型村粗空间的大小没有明确指定，只能取字面值true或false。
   - 包装器类型是在堆中创建一个对象。

3. 数组：

4. 类：

   - 成员变量如果没进行初始化，Java也会保证有一个默认值。
   - 局部变量如果没进行初始化，会提示错误。

5. 略

6. 略

7. 略

8. 注释

   - @see：引用其他类
   - {@link package.class#member label}：用label作为超链接文本
   - {@docRoot}：到文档根目录的相对路径
   - {@inheritDoc}：这个类的最直接的基类中继承相关文档到当前的文档注释中
   - @version version-information：版本
   - @author author-information：作者
   - @since：最早使用版本
   - @param parameter-name description
   - @return：返回值
   - @throws fully-qualified-class-name description：异常
   - @deprecated：过时
   - @Deprecated：过时

# 3、操作符

1. 基本类型的赋值是直接修改值。
2. ==和!=比较的是对象的引用。
3. 除了boolean外，其他类型都可以转换位其他基本类型。
4. 对float或double转换成整形，都进行了截尾操作。

# 4、执行流程

# 5、初始化与清理

1. this：当前对象的引用，或调用一个构造器。
   - 调用类的方法时，会隐式的把所操作对象的引用传递给类的方法。
2. static方法：没有this的方法。
3. 构造器初始化
   - 无法阻止自动初始化的进行，它在构造器被调用之前发生。
4. 数组初始化：数组是一个引用，所以不可以指定大小。用{}声明的数组的存储空间由编译器负责。

# 6、访问权限控制

1. 略
2. Java访问权限修饰词
3. 接口与实现
4. 类的访问权限

# 7、复用类

1. 组合语法

   1. 初始化引用的位置
      - 定义对象的地方。总能在构造器调用之前被初始化。
      - 在类的构造器中。
      - 在要用这些对象前，惰性初始化。在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外的负担。
      - 使用实例初始化。也就是把一个引用赋值给这个引用。
2. 继承语法

   1. 初始化基类：基类的子对象被包装在导出类对象内部。构造过程是从基类向外扩散的，所以基类在导出类构造器可以访问它之前，就以及完成了初始化。
   2. 基类构造器总会被调用，在导出类构造器之前被调用。
   3. 如果没有默认基类构造器，或者想调用一个带参数的基类构造器，就必须使用super显式的调用基类构造器，并且配以适当的参数列表。调用基类构造器是在导出类构造器中要做的第一件事。
3. 代理：使用代理类可以只使用成员对象的方法的某个子集。而不像组合和代理一样会使用所有方法。
4. 结合使用组合和继承

   1. 确保正确清理

      - 垃圾回收的顺序和生成顺序相反，也就是从派生类到基类。
      - 如果需要进行清理，最好是编写子集的清理方法，但不要使用finalize()。
5. 组合与继承之间的选择
   1. is-a是一个的关系是用继承来表达的。
   2. has-a有一个的关系是用组合来表达的。
6. 向上转型：将派生类向基类转型称为向上转型。也就是UML图的箭头是向上指的。
   - 使用继承的情况：新类需要向上转型。
7. final关键字
   1. final数据
      - 一个永不改变的编译时常量。
      - 一个在运行时被初始化的值，而你不希望它被改变。
      - final的基本类型是常量。
      - final的引用类型是引用恒定不变。final的值还是可能改变的。
      - final的数据在编译时有可能不知道它的值。如用一个随机数去填充final数据。
   2. final参数
      - 无法修改参数的引用。
      - 主要用来向匿名内部类传递数据。
   3. final方法
      - 继承类无法修改它的含义。
      - 类中所有的private方法隐式地指定为final的。虽然没什么意义。
   4. final类
      - 无法被继承。
      - 所有方法隐式的指定为final。
8. 初始化及类的加载
   - Java中的类文件在初次使用时才会加载。一般发生于创建类的第一个对象时，或者访问static域或static方法时。
   - 加载全过程
     1. 启动加载器找出Beetle类的.class代码，并加载它的基类代码。
     2. 根据基类中的static初始化，然后导出类的static初始化。
     3. 把对象中所有的基本类型设置位默认注，对象引用设置为null。
     4. 调用基类的构造器，实例变量初始化。
     5. 执行构造器其余部分。

# 8、多态

1. 多态的概念

   - 多态可以消除类型之间的耦合关系。
   - 也就是所有导出类可以通过一个基类来调用。
   - 多态也称为后期绑定和动态绑定。
   - 除了static方法和final和private方法外，其他方法都属于后期绑定。
   - 可扩展性。操作基类接口的方法不需要任何改动就可以应用于新类。
   - 可以将改变的事物与未变的事物分离开来。
   - 基类中方法1调用方法2，而派生类覆盖方法2，再次调用基类中的方法1时，会调用到派生类的方法2。
     - 因为是动态绑定的，调用基类的方法1时，回去动态检查要调用方法的实现，这时会检查到派生类的方法2。也可以理解为，虽然从基类中继承了一些东西，但是自己也改变了一些东西。
   - 导出类中，对于基类中的private方法，最好采用不同名字。
     - 因为private方法是final，不会被覆盖，如果同名可能会产生误解。
   - 任何域访问操作都将由编译器解析，因此域不是多态的。
     - 也就是如果派生类和基类都有相同的域，那么派生类会同时拥有自身和基类的两个域。想要调用基类的域必须super.field，默认是调用this.field。
     - 此情况在正常开发中不会发生。因为正常都将域设置为private。
     - 最好不要对基类和导出类中的域赋予相同的名字，会造成混淆。
   - 静态方法是与类，而不是单个对象关联的。

2. 构造器的多态。

   - 构造器实际上是static方法，隐式的。

   - 构造器调用顺序

     1. 调用基类构造器。不断递归下去。先调用跟类，一直到最低层的导出类。
     2. 按声明顺序调用成员的初始化方法。
     3. 调用导出类构造器的主体。

   - 摧毁顺序与初始化顺序相反，也就是先对导出类进行清理，然后才是基类。

   - 可以通过在被分享的类中设置引用计数器，这样可以确保在引用数为0时才摧毁对象。

     - 示例：

       ```java
       public class Human {
           
           private static long counter = 0;
           private final long id = counter++;
           private long refcount = 0;
           
           public Human() {
               addRef();
           }
           
           public void addRef() {
               this.refcount++;
           }
           
           protected void dispose() {
               if (--refcount == 0) {
                   System.out.println("Disposing " + this);
               }
           }
       }
       ```

   - 如果在基类中调用导出类的方法，可能导致导出类实际上的成员变量未初始化。

     - 初始化的过程：
       1. 在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的0。
       2. 调用基类构造器。在基类构造器内会调用导出类的覆盖后的方法。
       3. 按照声明的顺序调用成员的初始化方法。
       4. 调用导出类的构造器主体。

3. 协变返回类型：在导出类中覆盖的方法可以返回基类方法的返回类型的某种导出类型。

   - 示例：

     ```java
     public class Home {
         public Human print() {
             System.out.println("I am Home");
             return new Human();
         }
     }
     
     public class Family extends Home {
         @Override
         public Student print() {
             System.out.println("I am student");
             return new Student();
         }
     }
     ```

4. 向下转型

   - 一定要类型匹配才可以向下转型。
   - Java在运行期间采用“运行时类型识别（RTTI）”来确保类型的正确。

# 9、接口

1. 接口中声明的域默认是final和static的。
2. 使用接口+设配器模式实现无法修改类的解耦。
3. Java中的多重继承
   - 接口的方法可由实现类继承来的方法来实现。
   - 接口的核心原因：为了能够向上转型为多个基类型。
   - 次原因：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。
4. 组合接口时尽量不要使用相同的方法名，会造成混乱。也无法通过返回值来区分。
5. 接口中的域不是接口的一部分，它们的值被存储在该接口的静态存储区域内。
6. 接口嵌套
   - 用私有接口实现的共有类只能被自身类所使用，也就是有权使用私有接口的类，也就是包含此私有接口的类。
   - 嵌套在另一个接口中的接口自动就是public的。
   - private接口不能再定义它的类之外被实现。
7. 接口与工厂：可以使工厂返回的实现类通过接口进行解耦。

# 10、内部类

1. 内部类可以访问外围对象的所有成员，而不需要任何特殊条件。

   - 当外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。
   - 然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。
   - 构建内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错。

2. .this与.new

   - 其他类构造某类的内部类必须为其提供外围类的引用（.new）。

   - 拥有外围类之前是不可能创建内部类对象的，因为内部类对象会隐式地连接到创建它的外围类对象上。除非内部类是static的。

   - 通过外部类名.this获取外部类对象的引用。

   - 示例：

     ```java
     public interface FarInte {
         interface SubInte {
             void f();
         }
         void g();
     }
     
     /**
      * 实现了TestInte.SubInte接口
      */
     class OtherClass implements TestInte.SubInte {
         @Override
         public void f() {
             /**
              * 构造内部类必须为其提供外围类的引用（.new）
              */
             TestInte testInte =  new TestInte();
             TestInte.Inner inner = testInte.new Inner();
         }
     }
     
     /**
      * TestInte从FarInte继承了它的内部的SubInte接口
      */
     class TestInte implements FarInte, TestInte.SubInte{
         public class Inner {
             /**
              * 内部类对象引用外围类对象（.this）
              */
             public TestInte outer() {
                 return TestInte.this;
             }
         }
     
         @Override
         public void f() {
     
         }
     
         @Override
         public void g() {
             Inner inner = new Inner();
         }
     
     }
     ```

3. 内部类与向上转型

   - private内部类可以完全阻止任何依赖于类型的编码，并且完全隐藏的实现的细节。因为得到的只是指向基类或接口的引用。
   - protected内部类只能由外围类、子类及同包下的类访问。
   - 无法向下转型成priavate或protected的内部类（除非是继承自它的子类或是包内的类，因为可以访问类的名字），因为private内部类的名字不可以访问。
   - 从客户端程序员的角度，由于不能访问任何新增加的、原本不属于公共接口的方法，所有扩展接口是没有价值的。

4. 在方法和作用域的内部类

   - 方法内的内部类：只有定义此类的方法内才能使用。

     - 示例：

       ```java
       class OtherClass implements TestInte.SubInte {
           @Override
           public void f() {
               class Tes implements interface{
                   
               }
           }
       }
       ```

5. 匿名内部类

   - 表达式里的匿名类对象被自动向上转型为基类。
   - 对于有参数的基类构造器只需要传递参数给基类构造器即可。
   - 通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果。

6. 嵌套类：被声明为static的内部类。

   - 嵌套类与外围类没有关系。

   - 创建嵌套类对象不需要外围类的对象。

   - 不能从嵌套类的对象中访问非静态的外围类对象。

   - 普通内部类的字段与方法，只能放在类的外部层次上，所以普通内部类不能由static数据和static字段，也不能包含嵌套类。而嵌套类都可以有。

   - 接口内部的类

     - 嵌套类可以作为接口的一部分。自动是public和static的。

     - 示例：

       ```java
       public interface FarInte {
           void g(Date a);
       
           //嵌套类
           class InnerClass3 {
               //嵌套类里的内部类
               public class Test {
                   public void out3() {
                       System.out.println("dddddddddddddddddd");
                   }
               }
           }
       }
       ```

   - 内部类能够透明的访问所以它所嵌入的外围类的所有成员。

7. 内部类的作用

   - 每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
   - 内部类可以有多个实例，每个实例都有自己的状态信息，并且与外围类对象的信息相互独立。
   - 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
   - 创建内部类对象的时刻并不依赖于外围类对象的创建。
   - 内部类并没有is-a关系，它只是一个独立的实体。





