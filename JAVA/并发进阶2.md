# 1.任务执行

1. 任务边界。

   - 大多数服务器应用程序都以独立的客户请求为边界。

2. 如果可运行线程数量多于可用处理器的数量，那么有些线程将闲置。这些线程会占用资源。

3. Executor接口

   - Java类库中，任务执行的主要抽象不是Thread，而是Executor。
   - 将任务的提交过程与执行过程解耦开来，用Runnable表示任务。还实现了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。

4. 执行策略：将任务的提交与执行策略分离开

   - 在什么（What）线程中执行任务？

   - 任务按照什么（What）顺序执行（FIFO、LIFO、优先级）？

   - 有多少个（How Many）任务能并发执行？

   - 在队列中有多少个（How Many）任务在等待执行？

   - 如果系统由于过载而需要拒绝一个任务，那么应该选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？

   - 在执行一个任务之前或之后，应该进行哪些（What）动作？

   - 可以使用Executor来代替Thread获得更加灵活的执行策略。

     | 方法                    | 作用                                                         |
     | ----------------------- | ------------------------------------------------------------ |
     | newFixedThreadPool      | 创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到线程达到线程池的最大数量。（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程） |
     | newCachedThreadPool     | 创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。 |
     | newSingleThreadExecutor | 创建一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另外一个线程来替代。可以按照任务队列中的顺序来串行执行（如FIFO、LIFO、优先级） |
     | newScheduledThreadPool  | 创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务。类似于Timer。 |

   - **示例：**使用Executor来控制同时执行的线程数量

     ```java
     public class FixedThreadWebServer {
     
         private static final int NTHREADS = 2;
         private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);
     
         public static void main(String[] args) throws IOException {
             ServerSocket socket = new ServerSocket(80);
             while (true) {
                 final Socket connection = socket.accept();
                 Runnable task = () -> {
                     try {
                         handleRequest(connection);
                     } catch (IOException e) {
                         e.printStackTrace();
                     }
                 };
                 exec.execute(task);
             }
         }
     
         public static void handleRequest(Socket connection) throws IOException {
             PrintWriter pw=new PrintWriter(new OutputStreamWriter(connection.getOutputStream()));
             BufferedReader br=new BufferedReader(new InputStreamReader(connection.getInputStream()));
             String line;
             while ((line = br.readLine()) != null) {
                 System.out.println(line);
             }
         }
     
     }
     ```

5. ExecutorService接口：扩展Executor接口，提供生命周期功能

   ExecutorService生命周期有三种状态：运行、关闭和已终止。

   | 方法                                                         | 作用                                                         |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | void shutdown();                                             | 平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成，包括那些还未开始执行的任务。 |
   | List<Runnable> shutdownNow();                                | 尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。 |
   | boolean isShutdown();                                        |                                                              |
   | boolean isTerminated();                                      | 查看Executor是否已经终止。                                   |
   | boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; | 等待ExecutorService到达终止状态。调用此方法之后会立即调用shutdown，从而产生同步地关闭ExecutorService的效果。 |

6. 对异构任务进行并行化

   **示例：**使用Future实现并行地执行不同的任务。下载图片与渲染页面并行处理，并在下载完图片后渲染图片。（只有在图片全部下载后才能渲染图片）

   **注：**对异构任务进行分配时，很难提高性能，因为很难把两个异构任务平均分配给每个工作线程，而且需要一定的额外开销。例如，如果页面渲染很快，图片下载很慢，那么这个异构带来的收益将很小，而且代码复杂度增加很多。

   **所以：**只有当大量相互独立且同构的任务可以并发进行处理时，才能体现出程序的工作负载分配到多个任务中带来的真正性能提升。

   ```java
   public class FuturenRenderer {
   
       private static final int NTHREADS = 10;
       private static final ExecutorService exec = Executors.newFixedThreadPool(NTHREADS);
   
       public void start() throws IOException {
           ServerSocket socket = new ServerSocket(80);
           while (!exec.isShutdown()) {
               final Socket connection = socket.accept();
               exec.execute(() -> {
                    renderPage();
               });
           }
       }
   
       public void renderPage() throws IOException, InterruptedException {
   
           Callable<String> task = this::getImage; //获取图片任务
           Future<String> future = exec.submit(task); //提交任务
           renderText(); //渲染页面
           try {
               String image = future.get(); //等待获取图片结果返回
               renderImage(image); //获取到图片之后，开始加载渲染图片
           } catch (InterruptedException e) {
               Thread.currentThread().interrupt();
               //因为结果已经无效，取消任务
               future.cancel(true);
           } catch (ExecutionException e) {
               e.printStackTrace();
           }
       }
   
       private String getImage() throws InterruptedException {
           System.out.println("start get image");
           Thread.sleep(5000L);
           System.out.println("end get image");
           return "image";
       }
       private void renderText() throws InterruptedException {
           System.out.println("start render text");
           Thread.sleep(3000L);
           System.out.println("end render text");
       }
       private void renderImage(String image) throws InterruptedException {
           System.out.println("start render Image" + image);
           Thread.sleep(1000L);
           System.out.println("end render Image" + image);
       }
   }
   ```

7. CompletionService：Executor与BlockingQueue的组合

   - 可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已经完成的结果，而这些结果会在完成时将被封装为Future。

   - ExecutorCompletionService实现了CompletionService，并将计算部分委托给一个Executor。

   - ExecutorCompletionService里的QueueingFuture重写了FutureTask的done方法，在done方法里把任务结果加入BlockingQueue队列里（因为FutureTask在任务计算结束后会调用done方法）。因此，在这些方法得出结果之前会阻塞take和poll方法（take和poll方法委托给了BlockingQueue的take和poll方法）。

   - **示例：**并行的下载图片，并且每下载一张渲染一张。

     ```java
     public class Renderer {
         private final ExecutorService exec;
         
         public Renderer(ExecutorService exec) {
             this.exec = exec;
         }
         
         public void renderPage() throws IOException, InterruptedException {
             CompletionService<String> completionService = new ExecutorCompletionService<>(exec);
             String[] imgs = {"xhsf", "llala", "pdx"};
             for (String img : imgs) {
                 Callable<String> task = () -> getImage(img); //获取图片任务
                 completionService.submit(task); //提交任务给CompletionService
             }
             renderText(); //渲染页面
             try {
                 //每一次从结果队列里获取一张图片就渲染一张
                 for (int i = 0; i < imgs.length; i++) {
                     Future<String> future = completionService.take(); //等待获取图片结果返回
                     String image = future.get(); //获取结果
                     renderImage(image); //获取到图片之后，开始加载渲染图片
                 }
             } catch (InterruptedException e) {
                 Thread.currentThread().interrupt();
             } catch (ExecutionException e) {
                 e.printStackTrace();
             }
         }
     
         private String getImage(String name) throws InterruptedException {
             System.out.println("start get image" + name);
             Thread.sleep((long) (Math.random() * 50000)); //假装获取一张图片要半天
             System.out.println("end get image" + name);
             return name;
         }
         private void renderText() throws InterruptedException {
             System.out.println("start render text");
             Thread.sleep(3000L);
             System.out.println("end render text");
         }
         private void renderImage(String image) throws InterruptedException {
             System.out.println("start render Image" + image);
             Thread.sleep(1000L);
             System.out.println("end render Image" + image);
         }
     }
     ```

8. 为任务设置时限

   **示例1：**加载页面，并渲染图片，如果图片加载超时，就不加载了w

   ```java
   public class Renderer0 {
       private final ExecutorService exec;
       public Renderer0(ExecutorService exec) {
           this.exec = exec;
       }
   
       public void renderPage() throws IOException, InterruptedException {
           CompletionService<String> completionService = new ExecutorCompletionService<>(exec);
           String img = "xhsf";
               Callable<String> task = () -> getImage(img); //获取图片任务
               Future<String> future = completionService.submit(task); //提交任务给CompletionService
           renderText(); //渲染页面
           String image = null;
           try {
               image = future.get(10000L, TimeUnit.MILLISECONDS); //等待获取图片结果返回
               renderImage(image); //获取到图片之后，开始加载渲染图片
           } catch (InterruptedException e) {
               Thread.currentThread().interrupt();
           }  catch (ExecutionException e) {
               e.printStackTrace();
           } catch (TimeoutException e) { //如果超时则取消加载
               System.out.println("超时，图片取消加载" + image);
               future.cancel(true);
           }
       }
   
       private String getImage(String name) throws InterruptedException {
           System.out.println("start get image" + name);
           Thread.sleep((long) (Math.random() * 50000)); //假装获取一张图片要半天
           System.out.println("end get image" + name);
           return name;
       }
       private void renderText() throws InterruptedException {
           System.out.println("start render text");
           Thread.sleep(3000L);
           System.out.println("end render text");
       }
       private void renderImage(String image) throws InterruptedException {
           System.out.println("start render Image" + image);
           Thread.sleep(1000L);
           System.out.println("end render Image" + image);
       }
   }
   ```

   **示例2：**与示例1一样，但是是限定多张的最大加载时间，如果超过时间的图片将不再加载。

   ```java
   public class Renderer0 {
       private final ExecutorService exec;
       public Renderer0(ExecutorService exec) {
           this.exec = exec;
       }
   
       public void renderPage() throws IOException, InterruptedException {
           CompletionService<String> completionService = new ExecutorCompletionService<>(exec);
           String[] imgs = {"xhsf", "llala", "pdx"};
           List<Callable<String>> tasks = new ArrayList<>();
           for (String img : imgs) {
               Callable<String> task = () -> getImage(img); //获取图片任务
               tasks.add(task);
           }
           renderText(); //渲染页面
           List<Future<String>> futures = exec.invokeAll(tasks, 20000L, TimeUnit.MILLISECONDS); //获取结果集
   
           for (Future<String> f : futures) {
               try {
                   String image = f.get(); //加入未超时结果集
                   renderImage(image); //获取到图片之后，开始加载渲染图片
               } catch (ExecutionException e) {
                   e.printStackTrace();
               } catch (CancellationException e) {
                   System.out.println("加载图片超时，已取消加载");
               }
           }
       }
   
       private String getImage(String name) throws InterruptedException {
           System.out.println("start get image" + name);
           Thread.sleep((long) (Math.random() * 50000)); //假装获取一张图片要半天
           System.out.println("end get image" + name);
           return name;
       }
   
       private void renderText() throws InterruptedException {
           System.out.println("start render text");
           Thread.sleep(3000L);
           System.out.println("end render text");
       }
   
       private void renderImage(String image) throws InterruptedException {
           System.out.println("start render Image" + image);
           Thread.sleep(1000L);
           System.out.println("end render Image" + image);
       }
   
   }
   ```