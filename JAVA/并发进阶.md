# 并发进阶

# 1.线程安全性

1. i++并非线程安全的，因为i++会分成3步：读取v，将v+1，将结果写入v。

2. 线程安全的：当多个线程访问某个类时，不管如何运行，并且不需要在代码中使用任何同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

   简单来说：线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。

3. 一个类是无状态的：它既不包含任何域，也不包含任何对其他类中域的引用。

   •无状态对象一定是线程安全的。

   •在一个无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。

   •在一个无状态的类中添加多个状态时，如果这些状态完全由线程安全的对象来管理，那么这个类不一定是线程安全的。

   **例如：**

   ```java
   public class StatelessFactorizer extends HttpServlet {
       private final AtomicReference<Long> lastNumber = new AtomicReference<>();
       private final AtomicReference<Long> lastResult = new AtomicReference<>();
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           Long num = Long.valueOf(req.getParameter("num"));
           if (num.equals(lastNumber.get())) {
               resp.getOutputStream().println(num + ":" + lastResult.get());
           } else {
               Long result = num * num;
               lastNumber.set(num);
               lastResult.set(result);
               resp.getOutputStream().println(num + ":" + lastResult.get());
           }
       }
   }
   ```

   •要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

4. 竞争条件：当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞争条件。

5. 竞争条件-先检查后执行：通过一个可能失效的观测结果来决定下一步动作。

   **示例1：**首先观察某个条件为真（如文件x不存在），然后根据这个观察结果采用相应的动作（创建文件x），但在你观察到这个结果以及开始创建文件之间，观察的结果可能变得无效（另外一个线程在者期间创建了文件x），从而导致各种问题（数据被覆盖、文件被破坏等）。

   **示例2：**下面的延迟初始化代码：

   当线程A和B同时执行getInstance，就有可能创建两个instance，那么两次getInstance返回的结果就不同了。

   ```java
   @NotThreadSafe
   public class LazyInitRace {
       private Instance instance = null;
       public Instance getInstance() {
           if (instance == null) {
               instance = new Instance();
           }
           return instance;
       }
   }
   ```

6. 线程安全计数器

   ```java
   private final AtomicLong count = new AtomicLong(0);
   ```

7. 内置锁

   - 语法：synchronized(lock) {} 代码块或 synchronized修饰方法。

   - 每个java对象都可以用作一个实现同步的锁。

   - 获得内置锁的唯一途径就是进入这个锁保护的同步代码块或方法。

   - 内置锁是一种互质锁，即最多只有一个线程能持有这种锁。当A尝试获取一个由B持有的锁时，线程A必须等待或阻塞，直到B释放这个锁，如果B永远不释放锁，那么A也将永远地等下去。

   - **示例：**虽然很安全，但是并发性能极差。

     ```java
     public class StatelessFactorizer extends HttpServlet {
         @GuardedBy("this") private Long lastNumber = 0L;
         @GuardedBy("this") private Long lastResult = 0L;
         protected synchronized void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             Long num = Long.valueOf(req.getParameter("num"));
             if (num.equals(lastNumber)) {
                 resp.getOutputStream().println(lastResult);
             } else {
                 Long result = num * num;
                 lastNumber = num;
                 lastResult = result;
                 resp.getOutputStream().println(lastResult);
             }
         }
     }
     ```

   - 重入：重入意味着获取锁的操作的粒度是线程而不是调用。重入的实现是为每个锁关联一个获取计数值和一个所有者线程，当计数值为0时，这个锁没用被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁被释放。

     **示例：**子类改写了父类的synchronized方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码将产生死锁。每个doSomething方法在执行前都会获取Widget上的锁，然而，如果内置锁不是可重入的，那么在调用super.doSomething时将无法获得Widget上的锁，因为这个锁已经被持有，这个线程将永远停顿下去，等待一个永远也无法获得的锁。

     ```java
     public class Widget {
         public synchronized void doSomething(){}
     }
     class LoggingWidget extends Widget {
         public synchronized void doSomething(){
             System.out.println("doSomething");
             super.doSomething();
         }
     }
     ```

   - 不变性条件：对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由一个锁来保护。

   - 要确保同步代码块不要过小，并且不要将本应是原子操作的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。

     **示例：**把需要同步的代码块拆分出来，使在执行不需要同步的代码块使不会影响到其他线程的访问。

     - 但也无需把同步代码块分得过细，如把hits++分解到自己的同步代码块中，那样会影响到程序的性能。

     - 长时间计算或无法快速完成的操作时（如网络I/O），一定不要持有锁。

     ```java
     public class CachedFactorizer extends HttpServlet {
         @GuardedBy("this") private Long lastNumber = 0L;
         @GuardedBy("this") private Long lastResult = 0L;
         @GuardedBy("this") private int hits = 0; //命中数，可以配合缓存命中数算缓存命中率
         @GuardedBy("this") private int cacheHits = 0; //缓存命中数
         protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             Long num = Long.valueOf(req.getParameter("num"));
             Long result = null;
             synchronized (this) {
                 hits++;
                 if (num.equals(lastNumber)) {
                     cacheHits++;
                     result = lastResult;
                 }
             }
             if (result == null) {
                 result = num * num;
                 synchronized (this) {
                     lastNumber = num;
                     lastResult = result;
                 }
             }
             resp.getOutputStream().println(result);
         }
         protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             double cacheHitRate;
             synchronized (this) {
                 cacheHitRate = (double) cacheHits / (double) hits * 100;
             }
             resp.getOutputStream().println(cacheHitRate);
         }
     }
     ```

# 2.对象的共享

1. 内存可见性：关键字synchronized可以使方法有内存可见性（Memory Visibility）和防止重排序（Reordering）

   - 内置锁可以用于确保某个线程以一种可预测的方式来查看另外一个线程的执行结果。

   - 加锁不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

     **例如：**线程A获取锁内置M，进行操作，释放锁，线程B获取内置锁M。对于在M上的线程A调用unlock前的所有操作结果，对于在M上调用lock之后的的线程都是可见的。

2. 失效数据，如果某个线程设置某个变量的值，那么另外一个正在调用此变量的线程可能会调用到旧值（失效值）。

   **示例：**非线程安全的可变整数类

   ```java
   public class MutableInteger {
       private int value;
       public int get() {return  value;}
       public void set(int value) {this.value = value;}
   }
   ```

   **示例：**线程安全的可变整数类，因为get和set方法都被synchronized标识，会有内存可见性，所有不会出现失效数据。

   ```java
   public class MutableInteger {
       @GuardedBy("this") private int value;
       public synchronized int get() {return  value;}
       public synchronized void set(int value) {this.value = value;}
   }
   ```

3. 对于非volatile类型的64位数值变量（doubl额和long）。java内存模型要求，变量的读取操作和写入操作都必须是原子操作。但是对于非volatile类型的long和double变量，JVM运行将64位的读操作和写操作分解成为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很有可能会读取到某个值的高32位和另外一个值的低32位。因此，即使不考虑失效数据的问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。

4. volatile

   - volatile变量，当把变量声明位volatile类型后，编译器和运行时都会注意到这个变量是共享的，因此不会将改变量上的操作与其他内存操作一起重排序。

   - volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新的写入值。
   - volatile在访问变量时并不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。（在当前大多数处理器架构上，读取volatile变量的开销只比读取非volatile变量的开销略高一些）
   - volatile变量的正确使用方式：①确保它们自身状态的可见性；②确保它们所引用对象的状态的可见性；③标识一些重要的程序生命周期事件的发生（例如，初始化和关闭）。④用于标记是否退出某个循环。⑤用于标记某个操作是否完成，发生中断或状态的标志。
   - 使用volatile变量的必须条件：①对变量的写入操作不依赖变量的当前值，或者只有单个线程更新变量的值。②该变量不会与其他状态变量一起纳入不变性条件中。③在访问变量时不需要加锁。
   - 当线程A首先写入一个volatile变量并且线程B随后读取该变量时，在写入volatile变量之前对A可见的所有变量的值，在B读取了volatile变量后，对B也是可见的（即A写入时，存放变量是位置，是一个B也可以看到的位置）。而不是像放在寄存器那样，A的寄存器更新了，而B的寄存器不一定马上看得到。  

5. 发布与逸出

   - 发布：使对象能够在当前作用域之外的代码中使用，如私有对象被外部类的引用。

   - 逸出：某个不应该被发布的对象被发布时。

   - 封装的原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得困难。（如逸出私有对象）

   - this引用逸出

     **示例：**

     - 隐式的this引用逸出，因为内部类会持有外部封装的this的引用，当内部类EventListener发布时，外部封装的this也就逸出了。

     - 当且仅当构造函数返回时，对象才处于可预测和一致的状态。而EventListener发布时会把尚未构造完成的外部封装this对象逸出。

     - 如果在构造函数中启动一个线程，无论是显示的（将this传给构造函数），还是隐式的（由于Thread或Runnable是该对象的一个内部类），this与引用都会被新线程共享。在对象未完全构造之前，新的线程就可以看见它。在构造函数中创建线程并没有错，但是最好不要启动它，而是通过一个start或initialize方法来启动。

     - 在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），通用会导致this引用在构造过程中逸出。

     ```java
         public Parent(EventSource source) throws IllegalAccessException, NoSuchFieldException {
             source.registerListener(
                     new EventListener() {
                         public void onEvent() {
                             a = a + 3;
                             a = a + 4;
                         }
                     }
             );
             a = 333;
         }
     ```

     - 如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程。

       **示例：**

       ```java
       public class Parent {
           public int a;
           private final EventListener listener;
           private Parent(EventSource source) {
               listener = () -> {
                   a = a + 3;
                   a = a + 4;
               };
               a = 333;
           }
           public static Parent newInstance(EventSource source) {
               Parent parent = new Parent(source);
               //在构造函数完成之后，外部实例source都无法拿到listener的外部封装类parent的this引用
               source.registerListener(parent.listener);
               return parent;
           }
       }
       ```

6. 线程封闭：如果只是在单线程内访问数据，就不需要同步，被称为线程封闭（Thread Confinement）。

   - 栈封闭：局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。

     - 对于基本类型的局部变量，无论如果都不会破坏栈封闭性，因为外部无法取得基本类型的引用。
     - 对于引用类型的局部变量，只要不把引用逸出，也不会破坏栈的封闭性

     **示例：**

     ```java
     public int assembleList() {
         List<String> stringList;
         int num = 0;
         stringList = new ArrayList<>();
         num = num + 10;
         return num;
     }
     ```

   - ThreadLocal类：为每个线程提供该变量的一个副本，即每个线程都拥有自己单独的实例变量。

     其实就是如果该线程的ThreadLocalMap里面没有此ThreadLocal实例作为key（会计算成hash）的元素，就为此线程新建一个以ThreadLocal实例为key和以initialValue方法放回的参数为值的map，添加到该线程的ThreadLocalMap变量里。确保每个线程有自己的一个initialValue方法返回类型的实例。

     **示例：**

     ```java
     private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
         public Connection initialValue() { //重写initialValue方法
             try {
                 return DriverManager.getConnection("db_url");
             } catch (SQLException e) {
                 e.printStackTrace();
             }
             return null;
         }
     };
     public static Connection getConnection() {
         return connectionHolder.get();
     }
     ```

   - 当某个**频繁执行**的操作需要一个临时对象，例如一个缓冲区，而又希望避免再每次执行时都重写分配该临时对象，就可以使用ThreadLocal。

   - 如果需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换成ThreadLocal对象，可以维持线程安全性。（因为ThreadLocal对象会为每个线程分配一个副本）

7. 不变性：不可变对象一定是线程安全的。

   - 不变性的条件：

     ①对象创建以后其状态就不能修改；

     ②对象的所有域都是final类型；（但是如String这种本来就不可变的不需要）

     ③对象是正确创建的（在对象的创建期间，没有this引用逸出）。

8. final域：final类型是不可变的，final域也可以确保初始化过程的安全性。如果某个域是不可变的，将其声明为final是一个良好的编程习惯。

   **示例：**使用volatile类型来发布不可变对象

   - 每次有新的值都新建一个OneValueCache对象，因为OneValueCache对象是不可变的，所以使用此对象的类也是线程安全的。（例如在此例中就不会造成输入和结果不一致的情况）

   ```java
   public class OneValueCache {
       private final Long lastNumber;
       private final Long lastResult;
       public OneValueCache(Long lastNumber, Long lastResult) {
           this.lastNumber = lastNumber;
           this.lastResult = lastResult;
       }
       public Long getLastResult(Long number) {
           if (this.lastNumber == null || !this.lastNumber.equals(number)) {
               return null;
           }
           return this.lastResult;
       }
   }
   ```

   ```java
   public class VolatileCachedFactorizer extends HttpServlet {
       private volatile OneValueCache cache = new OneValueCache(null, null); //使得其他线程也可以立即看到新缓存的数据
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           Long num = Long.valueOf(req.getParameter("num"));
           Long result = cache.getLastResult(num);
           if (result == null) {
               result = num * num;
               cache = new OneValueCache(num, result); //每次都把输入和结果作为一个整体传到不可变的OneValueCache对象中
           }
           resp.getOutputStream().println(result);
       }
   }
   ```

9. 安全发布

   **示例：**别的线程在看到holder对象时，它可能还没有被初始化。（即holder对象将处于不一致状态）

   ```java
   class Test1 {
       public Holder holder;
       public Test1() {}
       public void initialize(){
           holder = new Holder(42);
       }
   }
   ```

   **示例：**虽然看起不会出错，但是构造函数会在子类构造函数运行之前，先将默认值写入所有的域，因此某个域的默认值可能会被视为失效，即下例抛出AssertionError异常。

   ```java
   public class Holder {
       private int n;
       public Holder(int n) {
           this.n = n;
       }
       public void assertSanity() {
           if (n != n)
               throw new AssertionError("this atatement is false");
       }
   }
   ```

   - 不可变对象：任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。

   - 安全地发布：必须对象的引用以及对象的状态都同时对其他线程可见。

     **①在静态初始化函数中初始化一个对象的引用。**

     ②将对象的引用保存到volatile类型的域或者AtomicReferance对象中。

     ③将对象的引用保存到某个正确构造对象的final类型域中。

     ④将对象的引用保存到一个由锁保护的域中。

   - 线程安全库中的容器类提供了以下的安全发布保证：对对象的设置和获取使用锁进行同步。

     ①通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。

     ②通过将某个元素放入Vector、CopyObWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。

     ③通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。

   - 通常，要发布一个静态构造对象，最简单和最安全的方式是使用静态的初始化器。因为静态初始化器由JVM在可u的初始化阶段执行，由于JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。

     **示例：**

     ```java
     public static Holder holder = Holder(42);
     ```

   - 事实不可变对象：对象从技术上来看是可变的，但是其状态在发布后不会再改变。

     - 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

       **例如：**虽然Date是可变的，但是事实上它并不会被程序改变。所以只要使用synchronizedMap中的同步机制就足以使Date值被安全发布。

       ```java
       Map<String, Date> lastLogin = Collections.synchronizedMap(new HashMap<>());
       ```

   - 可变对象：如果对象在构造后可以修改，那么安全发布只能保证“发布当时”状态的可见性。

     ①不可变对象可以通过任何机制来发布。

     ②事实不可变对象必须通过安全方式来发布。（后面就不用管了）

     ③可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

# 4.对象的组合

1. 设计线程安全的类，需要包含以下三个基本要素：

   ①找出构成对象状态的所有变量；

   ②找出约束状态变量的不变性条件；

   ③建立对象状态的并发访问管理策略。

2. 对象的状态：

   - 对象中所有的基本类型变量；
   - 其被引用对象的域；

3. 同步的需求：

   - 对象与变量都有一个状态空间，即所有可能的取值。
   - final类型的域使用得越多，就越能简化对象可能状态的分析过程。
   - 在许多类中都定义了一些不可变条件，用于判断状态是否是有效的。如Long.MIN_VALUE到Long.MAX_VALUE。
   - 后验条件：判断状态迁移是否是有效的，如Counter的当前状态为17，那么下一个状态只能是18。
   - 对无效状态进行封装，如果某个操作中存在无效的状态转换，那么该操作必须是原子的。
   - 包含多个变量的不变性条件的原子需求：这些相关的变量必须在单个原子操作中进行读取或更新。（不能先更新一个变量，释放锁然后再次获取锁，再更新其他的变量）

4. 依赖状态的操作：某个操作中包含有基于状态的先验条件。

   - 先验条件：如不能从空队列中移除一个元素，在删除元素前，队列必须处于非空状态。
   - 并发程序中要一直等到先验条件为真然后再执行该操作。
   - 等待某个条件为真的各种内置机制斗鱼内置锁机制紧密关联。要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类（如阻塞队列或信号量）。

5. 状态的所有权：只需要考虑状态所拥有的数据。

   - 对象封装它拥有的状态，对它封装的状态拥有所有权。
   - 对于从构造函数或者方法中传递进来的对象，类通常不拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权（例如，同步容器封装器的工厂方法）。
   - 容器类通常表现出一种“所有权分离”的形式，其容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态。如Servlet的ServletContext。
   - ServletContext对象必须是线程安全的，因为并发访问容器内的共享对象时，可能会产生相互干扰，所以这些对象要么是线程安全对象，要么是事实不可变对象，或者是由锁来保护的对象。

6. 实例封闭：将数据封装再对象内部，可以将数据的访问限制再对象的方法上，从而更容易确保线程再访问数据时总能持有正确的锁。

   **示例：**

   ```java
   public class PersonSet {
       @GuardedBy("this")
       private final Set<Person> mySet = new HashSet<>();
       public synchronized void addPerson(Person p) {
           mySet.add(p);
       }
       public synchronized boolean containsPersion(Person p) {
           return mySet.contains(p);
       }
   }
   ```

   - 被封装的对象一定不能超出它们既定的作用域。对象可以封闭再类的一个实例（例如作为类的一个私有成员）中，或者封闭再某个作用域内（例如作为一个局部变量），再或者封闭在线程内（例如某个线程中将对象从一个方法传递到另一个方法，而不是再多个线程之间共享该对象）。

   - 一些基本的容器类并非线程安全的，例如ArrayList和HashMap，但类库提供了包装器工厂方法（例如Collections.synchronizedList以及其类似方法），使得这些非线程安全的类可以在多线程环境中安全使用。这些工厂方法通过“装饰器（Decorator）”模式将容器类封装在一个同步的包装器对象上。只要包装器对象拥有对底层容器的唯一引用（即把底层容器对象封闭在包装器中），那么它就是线程安全的。

   - Java监视器模式：把对象的所有可变状态对封装起来，并由对象自己的内置锁来保护。

     **示例1：**使用私有锁来保护状态，客户端代码无法得到锁。

     ```java
     @ThreadSafe
     public final class Counter {
         private final Object lock = new Object();
         @GuardedBy("lock") private long value = 0;
         public long getValue() {
             synchronized (lock) {
                 return value;
             }
         }
         public long increment() {
             synchronized (lock) {
                 if (value == Long.MAX_VALUE) {
                     throw new IllegalStateException("counter overflow");
                 }
                 return ++value;
             }
         }
     }
     ```

     **示例2：**使用监视器模式的车辆跟踪例子

     **注：**其中MutablePoint是非线程安全的，但是由于tracker没有把它逸出，所以整体还是线程安全的。

     ```java
     @ThreadSafe
     public class MonitorVehicleTracker {
         @GuardedBy("this")
         private final Map<String, MutablePoint> locations;
         public MonitorVehicleTracker(Map<String, MutablePoint> locations) {
             this.locations = deepCopy(locations);
         }
         public synchronized Map<String, MutablePoint> getLocations() {
             return deepCopy(locations);
         }
         public synchronized MutablePoint getLocation(String id) {
             MutablePoint loc = locations.get(id);
             return loc == null ? null : new MutablePoint(loc);
         }
         public synchronized void setLocation(String id, int x, int y) {
             MutablePoint loc = locations.get(id);
             if (loc == null) {
                 throw new IllegalArgumentException("No such ID: " + id);
             }
             loc.x = x;
             loc.y = y;
         }
         private static Map<String,MutablePoint> deepCopy(Map<String, MutablePoint> locations) {
             Map<String, MutablePoint> result = new HashMap<>();
             for (String id : locations.keySet()) {
                 result.put(id, new MutablePoint(locations.get(id)));
             }
             return Collections.unmodifiableMap(result);
         }
     }
     ```

7. 线程安全性的委托：将线程安全性委托给线程安全的类来保证。

   **示例：**通过线程安全的ConcurrentMap和不可修改的Collections.unmodifiableMap包装器和不可修改的Point把Tracker的线程安全性委托给它们。

   ```java
   @ThreadSafe
   public class DelegatingVehicleTracker {
       private final ConcurrentMap<String, Point> locations;
       private final Map<String, Point> unmodifiableMap;
       public DelegatingVehicleTracker(Map<String, Point> points) {
           locations = new ConcurrentHashMap<>(points);
           unmodifiableMap = Collections.unmodifiableMap(locations);
       }
       public Map<String, Point> getLocations() {
           //返回一个非实时更新的map
   //        return Collections.unmodifiableMap(locations);
           return unmodifiableMap;
       }
       public Point getLocation(String id) {
           return locations.get(id);
       }
       public void setLocation(String id, int x, int y) {
           if (locations.replace(id, new Point(x, y)) == null) {
               throw new IllegalArgumentException("invalid vehicle name: " + id);
           }
       }
   }
   ```

   - CopyOnWriteArrayList：在增加、移除、修改元素时，都会对列表进行复制，复制一个副本。

     - CopyOnWriteArrayList适用于读操作远多于修改操作的并发场景中。

     - 最终一致：CopyOnWriteArrayList不能保证保证数据的实时性，比如A在用get请求时，B正在set元素，但是A拿到的可能是旧元素，因为get方法没有加锁。
     - 读写分离：读取CopyOnWriteArrayList的时候读取的是CopyOnWriteArrayList中的Object[] array，但是修改的时候，操作的是一个新的Object[] array，读和写操作的不是同一个对象。
     - 迭代器：用的是使用方法时的那个数组，如果期间数组有改变，那么会导致数据不一致。

   - **如果一个是由多个独立且线程安全的状态变量组成，并且所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。**

8. 发布状态变量：如果一个状态变量是线程安全的，并且没有任何不变性条件（如Long.MAX_VALUE）来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

   **示例：**Map是不可变的，但是里面的Point是可变的，且是线程安全的，可以发布给客户端。这样的Map是可以实时收到更新的。

   ```java
   @ThreadSafe
   public class MutablePoint {
       @GuardedBy("this") private int x;
       @GuardedBy("this") private int y;
       private MutablePoint(int[] a) {
           this(a[0], a[1]);
       }
       public MutablePoint(MutablePoint p) {
           this(p.get());
       }
       public MutablePoint(int x, int y) {
           this.x = x;
           this.y = y;
       }
       public synchronized int[] get() {
           return new int[] {x, y};
       }
       public synchronized void set(int x, int y) {
           this.x = x;
           this.y = y;
       }
   }
   
   
   @ThreadSafe
   public class PublishVehicleTracker {
       private final ConcurrentMap<String, MutablePoint> locations;
       private final Map<String, MutablePoint> unmodifiableMap;
       public PublishVehicleTracker(Map<String, MutablePoint> locations) {
           this.locations = new ConcurrentHashMap<>(locations);
           unmodifiableMap = Collections.unmodifiableMap(this.locations);
       }
       public Map<String, MutablePoint> getLocations() {
           //返回一个非实时更新的map
   //        return Collections.unmodifiableMap(locations);
           return unmodifiableMap;
       }
       public MutablePoint getLocation(String id) {
           return locations.get(id);
       }
       public void setLocation(String id, int x, int y) {
           if (!locations.containsKey(id)) {
               throw new IllegalArgumentException("invalid vehicle name: " + id);
           }
           locations.get(id).set(x, y); //实时更新Map里的Point
       }
   }
   ```

9. 直接扩展并添加新的线程安全方法。会破坏封装性。

   **示例：**

   ```java
   public class BetterVector<E> extends Vector<E> {
       public synchronized boolean putIfAbsent(E x) {
           boolean absent = !contains(x);
           if (absent) add(x);
           return absent;
       }
   }
   ```

10. 客户端加锁：使用某个对象X来为自身方法加锁。会破坏封装性。

    **示例：**

    ```java
    public class ListHelper<E> {
        public List<E> list = Collections.synchronizedList(new ArrayList<>());
        public boolean putIfAbsent(E x) {
            synchronized (list) {
                boolean absent = !list.contains(x);
                if (absent) list.add(x);
                return absent;
            }
        }
    }
    ```

11. 组合：将对象的操作委托给底层的对象，并附加功能。

    **示例：**

    - 用自身锁给底部操作加锁，所以无需关系list是否是线程安全的，而且性能消耗也很小，因为底层list上的同步不存在竞争。
    - 外部也无法访问底层的list。
    - 实际上是使用了Java的监视器模式。

    ```java
    @ThreadSafe
    public class ImprovedList<T> implements List<T> {
        private final List<T> list;
        public ImprovedList(List<T> list) {
            this.list = list;
        }
        public synchronized boolean putIfAbsent(T x) {
            boolean absent = !list.contains(x);
            if (absent) list.add(x);
            return absent;
        } 
        @Override
        public synchronized int size() { 
            return 0;
        }
    	//。。。
    }
    ```

12. 文档：对于线程安全类，需要再文档中标明线程安全的实现策略。

    - 设计同步策略需要考虑多个方面：
      - 将哪些变量声明未volatile类型
      - 哪些变量用锁来保护
      - 哪些锁保护哪些变量
      - 哪些变量必须是不可变的或者被封闭在线程中的
      - 哪些操作必须是原子操作等
    - 严格的细节实现需要文档化，以便日后维护。
    - 文档化的基础需求：
      - 是否线程安全
      - 在执行回调时是否持有一个锁
      - 是否有某些特定的锁会影响其行为

# 5.基础构造模块

1. 在某些情况下需要加锁来保护对容器类的符合操作。
   **示例1：**虽然Vector是线程安全的，但是此类并非线程安全的

   ```java
   public class VectorTest {
       public static Object getLast(Vector list) {
           int lastIndex = list.size() - 1;
           return list.get(lastIndex);
       }
       public static void deleteLast(Vector list) {
           int lastIndex = list.size() - 1;
           list.remove(lastIndex);
       }
   }
   ```

   **示例2：**通过客户端锁保证同步容器的复合操作线程安全性

   ```java
   public class VectorTest {
       public static Object getLast(Vector list) {
           synchronized (list) {
               int lastIndex = list.size() - 1;
               return list.get(lastIndex);
           }
       }
       public static void deleteLast(Vector list) {
           synchronized (list) {
               int lastIndex = list.size() - 1;
               list.remove(lastIndex);
           }
       }
   }
   ```

   **示例3：**在调用size和相应的get之间，Vector的长度可能会变化，这种风险在对Vector中的元素进行迭代时仍会出现。如果在执行迭代时，另外一个线程删除了一个元素，那么可能会抛出ArrayIndexOutOfBoundsException

   ```java
   for (int i = 0; i < list.size(); i++) {
       dosomething(list.get(i));
   }
   ```

   **示例4：**通过客户端加锁来解决不可靠迭代问题，但是会降低并发性，因为迭代期间其它线程无法访问它。

   ```java
   synchronized (list) {
       for (int i = 0; i < list.size(); i++) {
           dosomething(list.get(i));
       }
   }
   ```

2. 迭代器与ConcurrentModificationException

   - 如果迭代器在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException，这种检查是在没有同步的情况下进行的，因此可能看到失效的计数值。
   - 可以使用对容器的克隆，在副本上进行迭代，把副本封闭在线程内，因此其他线程不会在迭代期间对其进行修改，避免抛出ConcurrentModificationException。但是克隆会有显著的性能开销。

3. 隐藏迭代器

   - 编译器会将字符串的连接操作转换成调用StringBuilder.append(Object)，而这个方法又会调用toString方法，标准容器的toString方法将迭代容器，就可能抛出ConcurrentModificationException。
   - **封装对象的同步机制有助于确保实施同步策略。**
   - **容器的hashCode和equals**等方法也会间接地执行迭代操作，当容器作为另外一个容器的元素或键值时，就会出现这种情况。同样，**containsAll、removeAll和retainAll等方法**，以及把容器作为参数的构造函数，都会对容器进行迭代。**所有这些间接的迭代，都有可能抛出ConcurrentModificationException。**
   - 可以使用Conllections.synchronizedSet来包装HashSet，并且对同步代码进行封装，就不会出现ConcurrentModificationException异常。

4. 并发容器来代替同步容器可以极大的提高伸缩性并降低风险。

5. ConcurrentHashMap