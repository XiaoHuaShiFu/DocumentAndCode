# 并发进阶

# 1.线程安全性

1. i++并非线程安全的，因为i++会分成3步：读取v，将v+1，将结果写入v。

2. 线程安全的：当多个线程访问某个类时，不管如何运行，并且不需要在代码中使用任何同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

   简单来说：线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。

3. 一个类是无状态的：它既不包含任何域，也不包含任何对其他类中域的引用。

   •无状态对象一定是线程安全的。

   •在一个无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。

   •在一个无状态的类中添加多个状态时，如果这些状态完全由线程安全的对象来管理，那么这个类不一定是线程安全的。

   **例如：**

   ```java
   public class StatelessFactorizer extends HttpServlet {
       private final AtomicReference<Long> lastNumber = new AtomicReference<>();
       private final AtomicReference<Long> lastResult = new AtomicReference<>();
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           Long num = Long.valueOf(req.getParameter("num"));
           if (num.equals(lastNumber.get())) {
               resp.getOutputStream().println(num + ":" + lastResult.get());
           } else {
               Long result = num * num;
               lastNumber.set(num);
               lastResult.set(result);
               resp.getOutputStream().println(num + ":" + lastResult.get());
           }
       }
   }
   ```

   •要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

4. 竞争条件：当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞争条件。

5. 竞争条件-先检查后执行：通过一个可能失效的观测结果来决定下一步动作。

   **示例1：**首先观察某个条件为真（如文件x不存在），然后根据这个观察结果采用相应的动作（创建文件x），但在你观察到这个结果以及开始创建文件之间，观察的结果可能变得无效（另外一个线程在者期间创建了文件x），从而导致各种问题（数据被覆盖、文件被破坏等）。

   **示例2：**下面的延迟初始化代码：

   当线程A和B同时执行getInstance，就有可能创建两个instance，那么两次getInstance返回的结果就不同了。

   ```java
   @NotThreadSafe
   public class LazyInitRace {
       private Instance instance = null;
       public Instance getInstance() {
           if (instance == null) {
               instance = new Instance();
           }
           return instance;
       }
   }
   ```

6. 线程安全计数器

   ```java
   private final AtomicLong count = new AtomicLong(0);
   ```

7. 内置锁

   - 语法：synchronized(lock) {} 代码块或 synchronized修饰方法。

   - 每个java对象都可以用作一个实现同步的锁。

   - 获得内置锁的唯一途径就是进入这个锁保护的同步代码块或方法。

   - 内置锁是一种互质锁，即最多只有一个线程能持有这种锁。当A尝试获取一个由B持有的锁时，线程A必须等待或阻塞，直到B释放这个锁，如果B永远不释放锁，那么A也将永远地等下去。

   - **示例：**虽然很安全，但是并发性能极差。

     ```java
     public class StatelessFactorizer extends HttpServlet {
         @GuardedBy("this") private Long lastNumber = 0L;
         @GuardedBy("this") private Long lastResult = 0L;
         protected synchronized void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             Long num = Long.valueOf(req.getParameter("num"));
             if (num.equals(lastNumber)) {
                 resp.getOutputStream().println(lastResult);
             } else {
                 Long result = num * num;
                 lastNumber = num;
                 lastResult = result;
                 resp.getOutputStream().println(lastResult);
             }
         }
     }
     ```

   - 重入：重入意味着获取锁的操作的粒度是线程而不是调用。重入的实现是为每个锁关联一个获取计数值和一个所有者线程，当计数值为0时，这个锁没用被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁被释放。

     **示例：**子类改写了父类的synchronized方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码将产生死锁。每个doSomething方法在执行前都会获取Widget上的锁，然而，如果内置锁不是可重入的，那么在调用super.doSomething时将无法获得Widget上的锁，因为这个锁已经被持有，这个线程将永远停顿下去，等待一个永远也无法获得的锁。

     ```java
     public class Widget {
         public synchronized void doSomething(){}
     }
     class LoggingWidget extends Widget {
         public synchronized void doSomething(){
             System.out.println("doSomething");
             super.doSomething();
         }
     }
     ```

   - 

8. 

   

