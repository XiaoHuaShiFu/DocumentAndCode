# 1.ActomicXxxx类 提供原子性操作

***

 - AtomicInteger等提供了incrementAndGet和decrementAndGet的原子操作。

 ```java
   public static AtomicLong id = new AtomicLong();
   public void increase() {
       id.incrementAndGet();
       id.decrementAndGet();
   }
 ```

 - set方法并非原子性方法

 ```java
     id.set(value);
 ```

 - 如果要使用原子性的设置方法请使用compareAndSet(oldValue, newValue)

   此方法使用compareAndSwap确保值在current value == expect时才进行set操作.

   ```java
   do {
      expect = id.get();
      update = 111;
   } while (!id.compareAndSet(expect, update));
   ```

- 注: Java 8 支持通过updateAndSet(function)进行更新操作

   ```java
   id.updateAndGet(update -> update = 111);//返回新值
   id.accumulateAndGet(111, Math::max);//返回新值
   id.getAndUpdate(update -> update = 3);//返回原值
   id.getAndAccumulate(111, Math::max);//返回原值
   ```

- 注：以下也提供了相应的方法

   AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 
   AtomicIntegerArray，AtomicLongArray 
   AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater 
   AtomicMarkableReference，AtomicStampedReference，AtomicReferenceArray

 

# 2.LongAdder和LongAccumulator 避免乐观更新的开销

***

- 通过多个变量，再求总和的方式来避免乐观更新的开销。线程多时会自动增加新的加数。

  通常情况下，只有当所有工作都完成之后才需要求总和的值，对于这种情况，这种方法会很高效。

  ```java
  public final LongAdder adder = new LongAdder();
  public void increase() {
      adder.increment();
  }
  public long sum() {
      adder.sum();
  }
  
  ```

- LongAccumulator支持累加操作。

  ```java
  //提供操作和零元素，操作必须满足结合律和交换律
  public final LongAccumulator accumulator = new LongAccumulator(Long::sum, 0);
  //会把其中的一个变量以原子的方式进行更新（a = a op v）
  public void increase() {
      accumulator.accumulate(1);
  }
  public long get() {
      //会对所有数用对应的操作进行计算。
      accumulator.get();
  }
  ```

- DoubleAdder 和 DoubleAccumulator也提供相应的操作。

# 3.ThreadLocal&lt;T&gt; 为每个线程实例一个T对象

- ```java
  //这样每次用get的时候都会新建一个当前线程的一个SimpleDateFormat实例
  //确保当前线程的SimpleDateFormat的内部结果不会被并发所破坏
  public static final ThreadLocal<SimpleDateFormat> dateFormat =
          ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
  
  public void test() {
      //为当前线程设置一个新值
      dateFormat.set(new SimpleDateFormat());
      String dateStamp = dateFormat.get().format(new Date());
      //删除对应这个线程的值
      dateFormat.remove();
  }
  ```

- ThreadLocalRandom类也是相应的原理。

  ```java
  public void test() {
      //会返回当前线程的Random类实例
      //避免像java.util.Random那样虽然是线程安全的，当却一次只能提供一个线程使用
      int random = ThreadLocalRandom.current().nextInt();
  }
  ```

# 4.tryLock() 测试锁并立即返回的方法
***

- lock方法不能被打断，如果一个线程在获得锁时被中断，如果出现死锁，lock方法就无法终止。

  tryLock方法如果在等待期间被中断，将抛出InterrupedException异常，可以打破死锁。

  lockInterruptibly将提供一个无限期等待但可以被中断的锁。

  ```java
  //尝试获取一个锁，如果获取到锁返回true，否则立即返回false
  //可以设置超时参数如：bankLock.tryLock(100, TimeUnit.MILLISECONDS);
  //TimeUnit包括SECONDS、MILLISECONDS、MICROSECONDS、NANOSECONDS
  if (bankLock.tryLock()) {
      do something else 
      try {
          ...
      } finally {
          bankLock.unlock();
      }
  }
  
  try {
      //无限期等待但可以被中断的锁
      bankLock.lockInterruptibly();
  } catch (InterruptedException e) {
  }
  ```

- await带超时参数和被中断后还继续等待的变体方法。

  ```java
  try {
      while (accounts[from] < amount) {
          //带超时参数的条件
          sufficientFunds.await(100, TimeUnit.MILLISECONDS);
          //这个条件将不会被中断，即不会抛出InterruptedException
          sufficientFunds.awaitUninterruptibly();
      }
  ```

# 5.读写锁ReentrantReadWriteLock

- 分别对读和写分开加锁，对读线程的锁是共用的。

  示例：

  ```java
  private ReentrantReadWriteLock bankLock;
  //分别对读和写分开锁
  private Lock readLock;
  private Lock writeLock;
  public Bank8(){
      this.bankLock = new ReentrantReadWriteLock();
      //从读写锁获取读锁和写锁
      this.readLock = bankLock.readLock();
      this.writeLock = bankLock.writeLock();
  }
  public void transfer(int from, int to, double amount) {
      writeLock.lock();//锁住，将排斥其他的读操作和写操作。
      try {
  		do something else
      } finally {
          //解锁
          writeLock.unlock();
      }
  }
  public double getTotal() {
      readLock.lock();//可以被多个读操作共用的读锁，但会排斥所有写操作。
      try {
          do something else
      } finally {
          readLock.unlock();
      }
  }
  ```

